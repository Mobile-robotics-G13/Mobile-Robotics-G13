// ================= SENSOR SETUP =================
int AnalogValue[5] = {0, 0, 0, 0, 0};
int AnalogPin[5]   = {4, 5, 6, 7, 15};

// ================= MOTOR SETUP =================
// PWM pins
int motorLeftPWM    = 37;
int motorRightPWM   = 39;

// Direction/phase pins
int motorLeftPhase  = 38;
int motorRightPhase = 20;

// ================= CALIBRATION VALUES =================
int threshold = 3000;   // adjust if needed

// Set this depending on what your sensors do:
// true  = analog value is HIGH on white line
// false = analog value is LOW on white line
const bool WHITE_HIGH = true;

// Motor calibration (your values)
int leftBaseSpeed   = 175;
int rightBaseSpeed  = 172;

// Gentle correction speeds
int gentleInner = 165;
int gentleOuter = 172;

// Medium turn speeds
int leftTurnSpeed   = 198;
int rightTurnSpeed  = 190;

// Hard correction speeds (pivot)
int pivotFast = 185;
int pivotSlow = 80;

// If your motor driver does NOT allow reversing with the PHASE pin,
// set this to false and hard turns will become "sharp curves" instead of pivots.
const bool ALLOW_REVERSE = true;

// ================= HELPERS =================
bool isWhite(int reading) {
  // Returns true if sensor sees the white line
  if (WHITE_HIGH) return (reading > threshold);
  else            return (reading < threshold);
}

void setLeftMotor(bool forward, int pwm) {
  digitalWrite(motorLeftPhase, forward ? HIGH : LOW);
  analogWrite(motorLeftPWM, constrain(pwm, 0, 255));
}

void setRightMotor(bool forward, int pwm) {
  digitalWrite(motorRightPhase, forward ? HIGH : LOW);
  analogWrite(motorRightPWM, constrain(pwm, 0, 255));
}

void stopMotors() {
  analogWrite(motorLeftPWM, 0);
  analogWrite(motorRightPWM, 0);
}

// ================= MOTION FUNCTIONS =================
void driveForward() {
  setLeftMotor(true, leftBaseSpeed);
  setRightMotor(true, rightBaseSpeed);
}

// Turn LEFT = left slower, right faster
void turnLeft() {
  setLeftMotor(true, gentleInner);
  setRightMotor(true, rightTurnSpeed);
}

// Turn RIGHT = left faster, right slower
void turnRight() {
  setLeftMotor(true, leftTurnSpeed);
  setRightMotor(true, gentleInner);
}

// Slight LEFT
void turnSlightLeft() {
  setLeftMotor(true, gentleInner);
  setRightMotor(true, gentleOuter);
}

// Slight RIGHT
void turnSlightRight() {
  setLeftMotor(true, gentleOuter);
  setRightMotor(true, gentleInner);
}

// Hard LEFT: pivot (left reverse, right forward)
void turnHardLeft() {
  if (ALLOW_REVERSE) {
    setLeftMotor(false, pivotSlow);   // reverse slowly
    setRightMotor(true, pivotFast);   // forward fast
  } else {
    // fallback: sharp curve only (no reverse)
    setLeftMotor(true, pivotSlow);
    setRightMotor(true, pivotFast);
  }
}

// Hard RIGHT: pivot (right reverse, left forward)
void turnHardRight() {
  if (ALLOW_REVERSE) {
    setLeftMotor(true, pivotFast);
    setRightMotor(false, pivotSlow);
  } else {
    // fallback: sharp curve only (no reverse)
    setLeftMotor(true, pivotFast);
    setRightMotor(true, pivotSlow);
  }
}

// ================= SETUP =================
void setup() {
  Serial.begin(9600);

  pinMode(motorLeftPWM, OUTPUT);
  pinMode(motorLeftPhase, OUTPUT);
  pinMode(motorRightPWM, OUTPUT);
  pinMode(motorRightPhase, OUTPUT);

  stopMotors();
}

// ================= MAIN LOOP =================
void loop() {

  bool onWhite[5];

  // ===== SENSOR READING =====
  for (int i = 0; i < 5; i++) {
    AnalogValue[i] = analogRead(AnalogPin[i]);
    onWhite[i] = isWhite(AnalogValue[i]);

    Serial.print(AnalogValue[i]);
    Serial.print("\t");
  }

  Serial.print(" | ");
  for (int i = 0; i < 5; i++) {
    Serial.print(onWhite[i] ? 1 : 0);
    Serial.print(" ");
  }
  Serial.println();

  // Sensor indices:
  // [0] far left, [1] left, [2] center, [3] right, [4] far right

  // ===== LINE FOLLOWING LOGIC (forgiving & consistent) =====
  // Priority: hard corrections first, then gentle/medium, then straight
  if (onWhite[0]) {
    turnHardLeft();
  }
  else if (onWhite[4]) {
    turnHardRight();
  }
  else if (onWhite[1] && onWhite[2]) {
    turnSlightLeft();
  }
  else if (onWhite[2] && onWhite[3]) {
    turnSlightRight();
  }
  else if (onWhite[1]) {
    turnLeft();
  }
  else if (onWhite[3]) {
    turnRight();
  }
  else if (onWhite[2]) {
    driveForward();
  }
  else {
    // Line lost: keep last-known direction would be better,
    // but safest is stop for now.
    stopMotors();
  }

  delay(20);
}
