// =====================================================
// EEN1025 – Mobile Robotics
// Week 2: White Line Following (5 Sensors)
// =====================================================

// ================= SENSOR SETUP =================
// Sensor order: [0] FL | [1] L | [2] C | [3] R | [4] FR
int sensorPins[5]   = {4, 5, 6, 7, 15};
int sensorValue[5]  = {0, 0, 0, 0, 0};
bool onLine[5]      = {false, false, false, false, false};

// ================= MOTOR SETUP =================
int motorLeftPWM    = 37;
int motorLeftPhase  = 38;
int motorRightPWM   = 39;
int motorRightPhase = 20;

// ================= CALIBRATION =================
int threshold = 3000;   // white < threshold, black > threshold

// Straight (calibrated)
int leftBaseSpeed   = 175;
int rightBaseSpeed  = 172;

// Slight turns
int lightInnerWheel = 165;
int lightOuterWheel = 172;

// Hard turns
int hardTurnFast    = 185;
int hardTurnSlow    = 80;

// ================= SETUP =================
void setup() {
  Serial.begin(9600);

  pinMode(motorLeftPWM, OUTPUT);
  pinMode(motorLeftPhase, OUTPUT);
  pinMode(motorRightPWM, OUTPUT);
  pinMode(motorRightPhase, OUTPUT);

  stopMotors();
}

// ================= MAIN LOOP =================
void loop() {

  // -------- READ SENSORS --------
  for (int i = 0; i < 5; i++) {
    sensorValue[i] = analogRead(sensorPins[i]);
    onLine[i] = (sensorValue[i] < threshold);

    Serial.print(sensorValue[i]);
    Serial.print("\t");
  }
  Serial.println();

  // -------- LINE FOLLOWING LOGIC --------
  // Priority-based truth table (robust)

  // CENTER on line → straight
  if (onLine[2]) {
    driveForward();
  }

  // CENTER + LEFT → slight left
  else if (onLine[1]) {
    turnSlightLeft();
  }

  // CENTER + RIGHT → slight right
  else if (onLine[3]) {
    turnSlightRight();
  }

  // FAR LEFT only → hard left
  else if (onLine[0]) {
    turnHardLeft();
  }

  // FAR RIGHT only → hard right
  else if (onLine[4]) {
    turnHardRight();
  }

  // LINE LOST → stop
  else {
    stopMotors();
  }

  delay(10);  // fast response, stable
}

// ================= MOTOR FUNCTIONS =================

void driveForward() {
  digitalWrite(motorLeftPhase, HIGH);
  digitalWrite(motorRightPhase, HIGH);
  analogWrite(motorLeftPWM, leftBaseSpeed);
  analogWrite(motorRightPWM, rightBaseSpeed);
}

void turnSlightLeft() {
  digitalWrite(motorLeftPhase, HIGH);
  digitalWrite(motorRightPhase, HIGH);
  analogWrite(motorLeftPWM, lightInnerWheel);
  analogWrite(motorRightPWM, lightOuterWheel);
}

void turnSlightRight() {
  digitalWrite(motorLeftPhase, HIGH);
  digitalWrite(motorRightPhase, HIGH);
  analogWrite(motorLeftPWM, lightOuterWheel);
  analogWrite(motorRightPWM, lightInnerWheel);
}

void turnHardLeft() {
  digitalWrite(motorLeftPhase, HIGH);
  digitalWrite(motorRightPhase, HIGH);
  analogWrite(motorLeftPWM, hardTurnSlow);
  analogWrite(motorRightPWM, hardTurnFast);
}

void turnHardRight() {
  digitalWrite(motorLeftPhase, HIGH);
  digitalWrite(motorRightPhase, HIGH);
  analogWrite(motorLeftPWM, hardTurnFast);
  analogWrite(motorRightPWM, hardTurnSlow);
}

void stopMotors() {
  analogWrite(motorLeftPWM, 0);
  analogWrite(motorRightPWM, 0);
}
